using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using NuGetDefense.Core;

namespace NuGetDefense;

public class VulnerabilityReporter
{
    private readonly bool _separateMsBuildMessages;
    public List<string>? MsBuildMessages;
    public VulnerabilityReport? Report;
    public string VulnerabilityTextReport = "";

    public VulnerabilityReporter(bool separateMsBuildMessages = true) => _separateMsBuildMessages = separateMsBuildMessages;

    /// <summary>
    ///     Builds an object used for the various reporting methods
    /// </summary>
    /// <param name="vulnerabilityDictionary"></param>
    /// <param name="projects">Parsed Project-Packages-Dictionary</param>
    /// <param name="warnOnly">If True, suppresses all errors</param>
    public void BuildVulnerabilityReport(
        Dictionary<string, Dictionary<string, Vulnerability>> vulnerabilityDictionary,
        Dictionary<string, NuGetPackage[]> projects, bool warnOnly)
    {
        var distinctPackages = new List<NuGetPackage>();
        foreach (var package in projects.Values.SelectMany(x => x))
            if (distinctPackages.All(x => !string.Equals(x.PackageUrl, package.PackageUrl, StringComparison.CurrentCultureIgnoreCase)))
                distinctPackages.Add(package);

        Report = new()
        {
            VulnerabilitiesCount = vulnerabilityDictionary.Sum(x => x.Value.Count),
            Packages = distinctPackages.OrderBy(x => x.Id).ThenBy(x => x.Version)
                .Where(p => p.LineNumber != null
                            && vulnerabilityDictionary.ContainsKey(p.PackageUrl)
                            && vulnerabilityDictionary[p.PackageUrl].Any()
                )
                .Select(p => new VulnerableNuGetPackage
                {
                    Id = p.Id,
                    Version = p.Version,
                    Vulnerabilities = vulnerabilityDictionary[p.PackageUrl].Select(
                        v => new ReportedVulnerability
                        {
                            Description = v.Value.Description,
                            Cve = v.Value.Cve,
                            Cwe = v.Value.Cwe,
                            CvssScore = v.Value.CvssScore,
                            CvssVector = v.Value.Vector.ToString()
                        }).ToArray()
                }).ToArray()
        };
    }

    public void BuildVulnerabilityTextReport(Dictionary<string, Dictionary<string, Vulnerability>> vulnerabilityDictionary,
        IEnumerable<NuGetPackage> pkgs, string nuGetFile, bool warnOnly, double cvss3Threshold, out int numberOfVulns)
    {
        numberOfVulns = 0;
        if (_separateMsBuildMessages) MsBuildMessages = new();

        var logBuilder = new StringBuilder(VulnerabilityTextReport);
        var nuGetPackages = pkgs as NuGetPackage[] ?? pkgs.ToArray();
        logBuilder.AppendLine($"{vulnerabilityDictionary.Sum(ve => ve.Value.Count)} vulnerabilities found in {nuGetPackages.Count()} packages for {nuGetFile}.");
        foreach (var pkg in nuGetPackages.Where(p => vulnerabilityDictionary.ContainsKey(p.PackageUrl)))
        {
            var vulnerabilities = vulnerabilityDictionary[pkg.PackageUrl];

            logBuilder.AppendLine("*************************************");
            // TODO: Dependencies will need to be listed by package url when this is used.
            var dependantVulnerabilities = pkg.Dependencies.Where(dep => vulnerabilityDictionary.ContainsKey(dep));

            var warnForThisPackage = warnOnly && vulnerabilities.Any(v => v.Value.CvssScore <= cvss3Threshold && v.Value.CvssScore > -1);

            var vulnTotalMSbuildMessage = MsBuild.Log(nuGetFile, warnForThisPackage ? MsBuild.Category.Warning : MsBuild.Category.Error, pkg.LineNumber, pkg.LinePosition,
                $"{vulnerabilities.Count} vulnerabilities found for {pkg.Id} @ {pkg.Version}");

            if (vulnerabilities.Any())
            {
                if (_separateMsBuildMessages) MsBuildMessages.Add(vulnTotalMSbuildMessage);
                else logBuilder.AppendLine(vulnTotalMSbuildMessage);
            }

            var dependancies = dependantVulnerabilities as string[] ?? dependantVulnerabilities.ToArray();
            if (dependancies.Any())
            {
                var dependantVulnTotalMsBuildMessage = MsBuild.Log(nuGetFile, warnForThisPackage ? MsBuild.Category.Warning : MsBuild.Category.Error, pkg.LineNumber,
                    pkg.LinePosition,
                    $"{dependancies.Count()} vulnerabilities found for dependencies of {pkg.Id} @ {pkg.Version}");

                if (_separateMsBuildMessages) MsBuildMessages.Add(dependantVulnTotalMsBuildMessage);
                else logBuilder.AppendLine(dependantVulnTotalMsBuildMessage);
            }

            foreach (var cve in vulnerabilities.Keys)
            {
                var warnForThisVuln = warnOnly && vulnerabilities[cve].CvssScore <= cvss3Threshold && vulnerabilities[cve].CvssScore > -1;

                if (!warnForThisVuln) numberOfVulns++;

                var vulnMsBuildMessage = MsBuild.Log(nuGetFile, warnForThisVuln ? MsBuild.Category.Warning : MsBuild.Category.Error, cve, pkg.LineNumber, pkg.LinePosition,
                    $"{vulnerabilities[cve].Description}");

                if (_separateMsBuildMessages) MsBuildMessages.Add(vulnMsBuildMessage);
                else logBuilder.AppendLine(vulnMsBuildMessage);

                logBuilder.AppendLine($"Description: {vulnerabilities[cve].Description}");
                logBuilder.AppendLine($"CVE: {cve}");
                logBuilder.AppendLine($"CWE: {vulnerabilities[cve].Cwe}");
                logBuilder.AppendLine($"CVSS Score: {vulnerabilities[cve].CvssScore}");
                logBuilder.AppendLine($"CVSS Vector: {vulnerabilities[cve].Vector}");
                if (vulnerabilities[cve].References != null && vulnerabilities[cve].References.Any())
                {
                    logBuilder.AppendLine("References:");
                    foreach (var reference in vulnerabilities[cve].References) logBuilder.AppendLine(reference);
                }

                logBuilder.AppendLine("---------------------------");
            }

            foreach (var dependancy in dependancies)
            {
                vulnerabilities = vulnerabilityDictionary[dependancy];
                foreach (var cve in vulnerabilities.Keys)
                {
                    var warnForThisDepVuln = warnOnly && vulnerabilities[cve].CvssScore <= cvss3Threshold && vulnerabilities[cve].CvssScore > -1;

                    if (!warnForThisDepVuln) numberOfVulns++;

                    var vulnMsBuildMessage = MsBuild.Log(nuGetFile, warnForThisDepVuln ? MsBuild.Category.Warning : MsBuild.Category.Error, cve, pkg.LineNumber, pkg.LinePosition,
                        $"{dependancy}: {vulnerabilities[cve].Description}");

                    if (_separateMsBuildMessages) MsBuildMessages.Add(vulnMsBuildMessage);
                    else logBuilder.AppendLine(vulnMsBuildMessage);
                    logBuilder.AppendLine($"Description: {vulnerabilities[cve].Description}");
                    logBuilder.AppendLine($"CVE: {cve}");
                    logBuilder.AppendLine($"CWE: {vulnerabilities[cve].Cwe}");
                    logBuilder.AppendLine($"CVSS Score: {vulnerabilities[cve].CvssScore}");
                    logBuilder.AppendLine($"CVSS Vector: {vulnerabilities[cve].Vector}");
                    // if (vulnerabilities[cve].Version?.Length > 0)
                    //     logBuilder.AppendLine($"Affected Version: {vulnerabilities[cve].Version}");
                    logBuilder.AppendLine("---------------------------");
                }
            }
        }

        VulnerabilityTextReport = logBuilder.ToString();
    }
}