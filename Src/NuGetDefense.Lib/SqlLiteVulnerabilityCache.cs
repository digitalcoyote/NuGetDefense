using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Microsoft.Data.Sqlite;
using NuGetDefense.Core;
using static NuGetDefense.Core.Vulnerability;

namespace NuGetDefense;

/// <summary>
///     An initial implementation of a sqlite based cache.
/// </summary>
public class SqlLiteVulnerabilityCache
{
    public readonly string? Path;

    /// <summary>
    ///     Creates anew sqlLite Cache
    /// </summary>
    /// <param name="path">Path to the sqlite sqlLite</param>
    public SqlLiteVulnerabilityCache(string? path) => Path = path;

    /// <summary>
    ///     Enables/Disables the Cache
    /// </summary>
    public bool Enabled { get; set; } = true;

    public static void CreateNewSqlLiteCache(string? Path)
    {
        var connectionString = new SqliteConnectionStringBuilder
        {
            DataSource = Path
        };
        using var connection = new SqliteConnection(connectionString.ConnectionString);
        connection.Open();

        var createPackagesTableCommand = connection.CreateCommand();
        createPackagesTableCommand.CommandText = "CREATE TABLE packages(id INTEGER PRIMARY KEY, name TEXT, UNIQUE (name))";
        createPackagesTableCommand.ExecuteNonQuery();

        var createVulnerabilitySourcesTableCommand = connection.CreateCommand();
        createVulnerabilitySourcesTableCommand.CommandText = @"CREATE TABLE VulnerabilitySources(id INTEGER PRIMARY KEY, name TEXT, UNIQUE (name))";
        createVulnerabilitySourcesTableCommand.ExecuteNonQuery();

        var createAccessVectorTypesTableCommand = connection.CreateCommand();
        createAccessVectorTypesTableCommand.CommandText = @"CREATE TABLE AccessVectorTypes(id INTEGER PRIMARY KEY, name TEXT, UNIQUE (name))";
        createAccessVectorTypesTableCommand.ExecuteNonQuery();

        foreach (var accessVectorType in Enum.GetValues(typeof(AccessVectorType)))
        {
            var insertAccessVectorTypesTableCommand = connection.CreateCommand();
            insertAccessVectorTypesTableCommand.CommandText = @$"INSERT OR IGNORE INTO AccessVectorTypes (id, name) VALUES ({(int)accessVectorType} ,'{accessVectorType}')";
            insertAccessVectorTypesTableCommand.ExecuteNonQuery();
        }

        var createVulnerabilitiesTableCommand = connection.CreateCommand();
        createVulnerabilitiesTableCommand.CommandText =
            @"CREATE TABLE Vulnerabilities(id INTEGER PRIMARY KEY, package INTEGER, cve TEXT, cwe TEXT, description TEXT, score REAL, vector INTEGER, vendor TEXT, refs TEXT, FOREIGN KEY (vector) REFERENCES AccessVectorTypes(id), FOREIGN KEY (package) REFERENCES packages(id),
                            UNIQUE (package, cve))";
        createVulnerabilitiesTableCommand.ExecuteNonQuery();

        var createPackageVersionScanCacheTableCommand = connection.CreateCommand();
        createPackageVersionScanCacheTableCommand.CommandText =
            @"CREATE TABLE PackageVersionScanCache(id INTEGER PRIMARY KEY, version TEXT, VulnerabilitySourceId INTEGER, dateLastScanned TEXT, package INTEGER, 
FOREIGN KEY(VulnerabilitySourceId) REFERENCES VulnerabilitySources(id), FOREIGN KEY (package) REFERENCES packages(id), UNIQUE (version, VulnerabilitySourceId, package))";
        createPackageVersionScanCacheTableCommand.ExecuteNonQuery();

        var createVulnerableVersionsTableCommand = connection.CreateCommand();
        createVulnerableVersionsTableCommand.CommandText =
            @"CREATE TABLE VulnerableVersions(id INTEGER PRIMARY KEY, VulnerabilityId INTEGER, CacheId INTEGER, FOREIGN KEY (CacheId) REFERENCES PackageVersionScanCache(id), FOREIGN KEY (VulnerabilityId) REFERENCES Vulnerabilities(id), UNIQUE (CacheId, VulnerabilityId));";
        createVulnerableVersionsTableCommand.ExecuteNonQuery();
    }

    /// <summary>
    ///     Checks the cache and returns a list of packages for which no valid cache is found
    /// </summary>
    /// <param name="Path">Path to sqlite cache</param>
    /// <param name="pkgs">packages to check cache for</param>
    /// <param name="maxAge">maximum age to consider a cache valid</param>
    /// <param name="cachedPackages">packages that have proper caches, ordered from oldest cache to newest</param>
    /// <param name="SourceId">Name of the Vulnerability Source that the cache is being checked for</param>
    /// <returns>List of packages that have no valid cache</returns>
    public List<NuGetPackage> GetUncachedPackages(IEnumerable<NuGetPackage> pkgs, TimeSpan maxAge, string SourceId, out NuGetPackage[] cachedPackages)
    {
        if (!Enabled)
        {
            cachedPackages = Array.Empty<NuGetPackage>();
            return pkgs.ToList();
        }

        List<NuGetPackage> uncachedPackages = new();
        List<(NuGetPackage Package, DateTime DateChecked)> datePackageTuples = new();
        foreach (var pkg in pkgs)
        {
            var connectionString = new SqliteConnectionStringBuilder
            {
                DataSource = Path
            };
            using var connection = new SqliteConnection(connectionString.ConnectionString);
            connection.Open();

            var lastCacheDateCommand = connection.CreateCommand();
            lastCacheDateCommand.CommandText = $@"Select dateLastScanned from PackageVersionScanCache 
                where package = (select id from packages where name like '{pkg.Id}') and 
                      VulnerabilitySourceId = (select Id from VulnerabilitySources where name = '{SourceId}')";

            lastCacheDateCommand.Parameters.Add(new("$SourceId", SourceId));
            lastCacheDateCommand.Parameters.Add(new("$packageName", pkg.Id));

            //TODO: Recheck all queries as sourceID has not been checked in most and needs to be upserted

            var dateLastChecked = DateTime.Parse((string)(lastCacheDateCommand.ExecuteScalar() ?? "1/1/0001"), CultureInfo.InvariantCulture);


            if (dateLastChecked.Add(maxAge) < DateTime.Now) uncachedPackages.Add(pkg);
            else datePackageTuples.Add((pkg, dateLastChecked));
        }

        datePackageTuples.Sort((x, y) =>
        {
            var (_, firstDateChecked) = x;
            var (_, secondDateChecked) = y;
            return firstDateChecked == secondDateChecked ? 0 : firstDateChecked < secondDateChecked ? -1 : 1;
        });
        cachedPackages = datePackageTuples.Select(x => x.Package).ToArray();
        return uncachedPackages;
    }

    public void UpdateCache(Dictionary<string, Dictionary<string, Vulnerability>> reportedVulnerabilities, IEnumerable<NuGetPackage> updatedPkgs, string sourceName)
    {
        if (!Enabled) return;

        var connectionString = new SqliteConnectionStringBuilder
        {
            DataSource = Path
        };
        using var connection = new SqliteConnection(connectionString.ConnectionString);
        connection.Open();

        var upsertVulnerabilitySourcesCommand = connection.CreateCommand();
        upsertVulnerabilitySourcesCommand.CommandText = "INSERT OR IGNORE INTO VulnerabilitySources (name) VALUES($sourceName)";
        upsertVulnerabilitySourcesCommand.Parameters.AddWithValue("$sourceName", sourceName);
        upsertVulnerabilitySourcesCommand.ExecuteNonQuery();

        foreach (var updatedPkg in updatedPkgs)
        {
            var upsertPackagesCommand = connection.CreateCommand();
            upsertPackagesCommand.CommandText = "INSERT OR IGNORE INTO packages (name) VALUES($packageName)";
            upsertPackagesCommand.Parameters.AddWithValue("$packageName", updatedPkg.Id.ToLower());
            upsertPackagesCommand.ExecuteNonQuery();

            var upsertPackageVersionScanCacheCommand = connection.CreateCommand();
            upsertPackageVersionScanCacheCommand.Parameters.AddWithValue("$packageVersion", updatedPkg.Version.ToLower());
            upsertPackageVersionScanCacheCommand.Parameters.AddWithValue("$packageName", updatedPkg.Id.ToLower());
            upsertPackageVersionScanCacheCommand.Parameters.AddWithValue("$scanDate", DateTime.UtcNow.ToString(CultureInfo.InvariantCulture));
            upsertPackageVersionScanCacheCommand.Parameters.AddWithValue("$sourceName", sourceName);
            upsertPackageVersionScanCacheCommand.CommandText = @"INSERT INTO PackageVersionScanCache(version, VulnerabilitySourceId, dateLastScanned, package)
                 VALUES($packageVersion, (Select id from VulnerabilitySources where name = $sourceName), $scanDate, (select Id from packages where name = $packageName)) ON CONFLICT(version, VulnerabilitySourceId, package) DO UPDATE SET dateLastScanned = $scanDate";
            upsertPackageVersionScanCacheCommand.ExecuteNonQuery();
        }

        if (reportedVulnerabilities is null) return;

        foreach (var (packageUrl, vulnerabilities) in reportedVulnerabilities)
        {
            var packageName = packageUrl.Substring(10, packageUrl.Length - 10 - packageUrl.Substring(packageUrl.IndexOf('@')).Length);
            var packageVersion = packageUrl[(packageUrl.IndexOf('@') + 1)..];

            foreach (var (_, vulnerability) in vulnerabilities)
            {
                var upsertVulnerabilitiesCommand = connection.CreateCommand();
                upsertVulnerabilitiesCommand.CommandText = @"INSERT Or REPLACE INTO Vulnerabilities (package, cve, cwe, description, score, vector, vendor, refs)
                      VALUES((SELECT Id FROM Packages WHERE name = $packageName), $cve, $cwe, $description, $score, $vector, $vendor, $refs)";
                upsertVulnerabilitiesCommand.Parameters.AddWithValue("$packageName", packageName);
                upsertVulnerabilitiesCommand.Parameters.AddWithValue("$cve", vulnerability.Cve);
                upsertVulnerabilitiesCommand.Parameters.AddWithValue("$cwe", vulnerability.Cwe ?? "");
                upsertVulnerabilitiesCommand.Parameters.AddWithValue("$description", vulnerability.Description);
                upsertVulnerabilitiesCommand.Parameters.AddWithValue("$score", vulnerability.CvssScore);
                upsertVulnerabilitiesCommand.Parameters.AddWithValue("$vector", (int)vulnerability.Vector).SqliteType = SqliteType.Integer;
                upsertVulnerabilitiesCommand.Parameters.AddWithValue("$vendor", vulnerability.Vendor);
                upsertVulnerabilitiesCommand.Parameters.AddWithValue("$refs", string.Join(' ', vulnerability.References));
                upsertVulnerabilitiesCommand.ExecuteNonQuery();


                // TODO: Debug this query to make sure Vulnerable versions are input correctly
                var upsertVulnerableVersionsCommand = connection.CreateCommand();
                upsertVulnerableVersionsCommand.CommandText = @"INSERT OR IGNORE INTO VulnerableVersions (VulnerabilityId, CacheId) 
                    VALUES((SELECT Id FROM Vulnerabilities WHERE package = (SELECT Id FROM Packages WHERE name = $packageName) AND cve = $cve), 
                           (SELECT Id FROM PackageVersionScanCache WHERE package = (SELECT Id FROM Packages WHERE name = $packageName) 
                            AND VulnerabilitySourceId = (Select id from VulnerabilitySources where name = $sourceName)
                            AND version = $version))";
                upsertVulnerableVersionsCommand.Parameters.AddWithValue("$packageName", packageName);
                upsertVulnerableVersionsCommand.Parameters.AddWithValue("$sourceName", sourceName);
                upsertVulnerableVersionsCommand.Parameters.AddWithValue("$version", packageVersion);
                upsertVulnerableVersionsCommand.Parameters.AddWithValue("$cve", vulnerability.Cve);
                upsertVulnerableVersionsCommand.ExecuteNonQuery();
            }
        }
    }

    public void GetPackagesCachedVulnerabilitiesForSource(IEnumerable<NuGetPackage> cachedPackages, string sourceName,
        ref Dictionary<string, Dictionary<string, Vulnerability>> vulnDict)
    {
        if (!Enabled) return;

        foreach (var cachedPkg in cachedPackages) GetPackageCachedVulnerabilitiesForSource(cachedPkg, sourceName, ref vulnDict);
    }


    public void GetPackageCachedVulnerabilitiesForSource(NuGetPackage package, string sourceName,
        ref Dictionary<string, Dictionary<string, Vulnerability>> vulnDict)
    {
        if (!Enabled) return;

        var connectionString = new SqliteConnectionStringBuilder
        {
            DataSource = Path
        };
        using var connection = new SqliteConnection(connectionString.ConnectionString);
        connection.Open();

        var command = connection.CreateCommand();
        command.CommandText =
            $@"SELECT cve, cwe, description, score, vector, vendor, refs FROM vulnerabilities WHERE id IN
                    (SELECT VulnerabilityId FROM VulnerableVersions WHERE CacheId IN 
                        (SELECT id FROM PackageVersionScanCache WHERE package = (Select Id from Packages where name = '{package.Id.ToLower()}') AND version = '{package.Version.ToLower()}' AND VulnerabilitySourceId IN
                            (SELECT id FROM VulnerabilitySources WHERE name = '{sourceName}')))";
        command.Parameters.AddWithValue("$packageName", package.Id.ToLower());
        command.Parameters.AddWithValue("$version", package.Version.ToLower());
        command.Parameters.AddWithValue("$sourceName", sourceName);

        vulnDict ??= new();
        var vulnList = new List<Vulnerability>();
        using var reader = command.ExecuteReader();
        while (reader.Read())
            vulnList.Add(new((string)reader["cve"], (double)reader["score"], (string)reader["cwe"], (string)reader["description"],
                ((string)reader["refs"]).Split(' '), Enum.Parse<AccessVectorType>(((long)reader["vector"]).ToString()), (string)reader["vendor"]));
        ;

        if (vulnList.Count <= 0) return;
        if (!vulnDict.ContainsKey(package.PackageUrl)) vulnDict.Add(package.PackageUrl, new());
        for (var i = 0; i < vulnList.Count; i++) vulnDict[package.PackageUrl].Add(vulnList[i].Cve, vulnList[i]);
    }
}